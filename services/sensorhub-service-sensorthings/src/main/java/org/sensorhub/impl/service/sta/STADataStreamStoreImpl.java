/***************************** BEGIN LICENSE BLOCK ***************************

The contents of this file are subject to the Mozilla Public License, v. 2.0.
If a copy of the MPL was not distributed with this file, You can obtain one
at http://mozilla.org/MPL/2.0/.

Software distributed under the License is distributed on an "AS IS" basis,
WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
for the specific language governing rights and limitations under the License.
 
Copyright (C) 2019 Sensia Software LLC. All Rights Reserved.
 
******************************* END LICENSE BLOCK ***************************/

package org.sensorhub.impl.service.sta;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.h2.mvstore.MVBTreeMap;
import org.h2.mvstore.MVStore;
import org.h2.mvstore.RangeCursor;
import org.sensorhub.api.common.BigId;
import org.sensorhub.api.data.DataStreamInfo;
import org.sensorhub.api.data.IDataStreamInfo;
import org.sensorhub.api.datastore.DataStoreException;
import org.sensorhub.api.datastore.obs.DataStreamFilter;
import org.sensorhub.api.datastore.obs.DataStreamKey;
import org.sensorhub.api.datastore.obs.IDataStreamStore;
import org.sensorhub.api.datastore.system.ISystemDescStore;
import org.sensorhub.impl.datastore.h2.MVVoidDataType;
import org.sensorhub.impl.service.sta.STADataStreamStoreTypes.*;


/**
 * <p>
 * Wrapper for {@link IDataStreamStore} to handle associations with Thing
 * entities.
 * </p>
 *
 * @author Alex Robin
 * @date Oct 14, 2019
 */
class STADataStreamStoreImpl implements ISTADataStreamStore
{
    private static final String THING_DATASTREAMS_MAP_NAME = "@thing_dstreams";
    private static final String DATASTREAM_THING_MAP_NAME = "@dstream_thing";
    
    MVStore mvStore;
    IDataStreamStore delegateStore;
    int idScope;
    ISTAThingStore thingStore;
    MVBTreeMap<MVDataStreamThingKey, Boolean> thingDataStreamsIndex;
    MVBTreeMap<Long, Long> dataStreamThingIndex;
    
    
    STADataStreamStoreImpl(STADatabase database, IDataStreamStore delegateStore)
    {
        this.mvStore = database.getMVStore();
        this.thingStore = database.getThingStore();
        this.delegateStore = delegateStore;
        
        // Thing-Datastreams association map
        String mapName = THING_DATASTREAMS_MAP_NAME + ":" + delegateStore.getDatastoreName();
        this.thingDataStreamsIndex = mvStore.openMap(mapName, new MVBTreeMap.Builder<MVDataStreamThingKey, Boolean>()
            .keyType(new MVThingDataStreamKeyDataType())
            .valueType(new MVVoidDataType()));
        
        // Datastream-Thing association map
        mapName = DATASTREAM_THING_MAP_NAME + ":" + delegateStore.getDatastoreName();
        this.dataStreamThingIndex = mvStore.openMap(mapName, new MVBTreeMap.Builder<Long, Long>());
    }
    
    
    @Override
    public DataStreamKey add(IDataStreamInfo dsInfo) throws DataStoreException
    {
        return add(0L, dsInfo);
    }
    
    
    @Override
    public DataStreamKey add(long thingID, IDataStreamInfo dsInfo) throws DataStoreException
    {
        // synchronize on MVStore to avoid autocommit in the middle of things
        synchronized (mvStore)
        {
            long currentVersion = mvStore.getCurrentVersion();
            
            try
            {
                var dsKey = delegateStore.add(dsInfo);
                putThingAssoc(thingID, dsKey.getInternalID().getIdAsLong());
                return dsKey;
            }
            catch (Exception e)
            {
                mvStore.rollbackTo(currentVersion);
                throw e;
            }
        }
    }
    

    @Override
    public IDataStreamInfo put(DataStreamKey key, IDataStreamInfo value)
    {
        return delegateStore.put(key, value);
    }
    
    
    @Override 
    public IDataStreamInfo put(long thingID, DataStreamKey key, IDataStreamInfo value)
    {
        // synchronize on MVStore to avoid autocommit in the middle of things
        synchronized (mvStore)
        {
            long currentVersion = mvStore.getCurrentVersion();
            
            try
            {
                // we need to create a pure DataStreamInfo before adding to DB
                IDataStreamInfo pureDsInfo = DataStreamInfo.Builder.from(value).build();
                
                IDataStreamInfo oldValue = delegateStore.put(key, pureDsInfo);
                putThingAssoc(thingID, key.getInternalID().getIdAsLong());
                return oldValue;
            }
            catch (Exception e)
            {
                mvStore.rollbackTo(currentVersion);
                throw e;
            }
        }
    }
    
    
    @Override
    public void putThingAssoc(long thingID, long dsID)
    {
        // remove previous assoc if any
        Long oldThingID = dataStreamThingIndex.remove(dsID);
        if (oldThingID != null)
            thingDataStreamsIndex.remove(new MVDataStreamThingKey(oldThingID, dsID));
        
        // create new assoc
        var assocKey = new MVDataStreamThingKey(thingID, dsID);
        thingDataStreamsIndex.put(assocKey, Boolean.TRUE);
        dataStreamThingIndex.put(assocKey.dataStreamID, assocKey.thingID);
    }


    public IDataStreamInfo remove(Object key)
    {
        // synchronize on MVStore to avoid autocommit in the middle of things
        synchronized (mvStore)
        {
            long currentVersion = mvStore.getCurrentVersion();
            
            try
            {
                IDataStreamInfo oldValue = delegateStore.remove(key);
                removeThingAssoc((Long)key);
                return oldValue;
            }
            catch (Exception e)
            {
                mvStore.rollbackTo(currentVersion);
                throw e;
            }
        }
    }
    
    
    void removeThingAssoc(Long key)
    {
        long thingID = dataStreamThingIndex.remove(key);
        var assocKey = new MVDataStreamThingKey(thingID, key);
        thingDataStreamsIndex.remove(assocKey);
    }


    @Override
    public BigId getAssociatedThing(long dataStreamID)
    {
        var id = dataStreamThingIndex.get(dataStreamID);
        return BigId.fromLong(idScope, id);
    }
    
    
    Stream<Long> getDataStreamIdsByThing(long thingID)
    {
        MVDataStreamThingKey first = new MVDataStreamThingKey(thingID, 0);
        MVDataStreamThingKey last = new MVDataStreamThingKey(thingID, Long.MAX_VALUE);
        var cursor = new RangeCursor<>(thingDataStreamsIndex, first, last);
        return cursor.keyStream()
            .map(k -> k.dataStreamID);
    }


    public Stream<Entry<DataStreamKey, IDataStreamInfo>> selectEntries(DataStreamFilter filter, Set<DataStreamInfoField> fields)
    {
        if (filter instanceof STADataStreamFilter)
        {
            var thingFilter = ((STADataStreamFilter)filter).getThings();
            if (thingFilter != null)
            {
                TreeSet<BigId> datastreamIDs = thingStore.selectKeys(thingFilter)
                    .flatMap(id -> getDataStreamIdsByThing(id.getInternalID().getIdAsLong()))
                    .map(id -> BigId.fromLong(0, id))
                    .collect(Collectors.toCollection(TreeSet::new));
                
                return thingStore.selectKeys(thingFilter)
                    .flatMap(id -> delegateStore.selectEntries(new DataStreamFilter.Builder()
                        .withInternalIDs(datastreamIDs)
                        .build(), fields));
            }
        }
        
        return delegateStore.selectEntries(filter);
    }


    public String getDatastoreName()
    {
        return delegateStore.getDatastoreName();
    }


    public long getNumRecords()
    {
        return delegateStore.getNumRecords();
    }


    public IDataStreamInfo getLatestVersion(String sysUID, String outputName)
    {
        return delegateStore.getLatestVersion(sysUID, outputName);
    }


    public Stream<IDataStreamInfo> select(DataStreamFilter query)
    {
        return delegateStore.select(query);
    }


    public Stream<DataStreamKey> selectKeys(DataStreamFilter query)
    {
        return delegateStore.selectKeys(query);
    }


    public Entry<DataStreamKey, IDataStreamInfo> getLatestVersionEntry(String sysUID, String outputName)
    {
        return delegateStore.getLatestVersionEntry(sysUID, outputName);
    }


    public long removeEntries(DataStreamFilter query)
    {
        return delegateStore.removeEntries(query);
    }


    public long countMatchingEntries(DataStreamFilter query)
    {
        return delegateStore.countMatchingEntries(query);
    }


    public void commit() throws DataStoreException
    {
        delegateStore.commit();
    }


    public void backup(OutputStream is) throws IOException
    {
        delegateStore.backup(is);
    }


    public void restore(InputStream os) throws IOException
    {
        delegateStore.restore(os);
    }


    public boolean isReadOnly()
    {
        return delegateStore.isReadOnly();
    }


    public void putAll(Map<? extends DataStreamKey, ? extends IDataStreamInfo> map)
    {
        delegateStore.putAll(map);
    }


    public int size()
    {
        return delegateStore.size();
    }


    public boolean isEmpty()
    {
        return delegateStore.isEmpty();
    }


    public boolean containsKey(Object key)
    {
        return delegateStore.containsKey(key);
    }


    public boolean containsValue(Object value)
    {
        return delegateStore.containsValue(value);
    }


    public IDataStreamInfo get(Object key)
    {
        return delegateStore.get(key);
    }


    public void clear()
    {
        delegateStore.clear();
    }


    public Set<DataStreamKey> keySet()
    {
        return delegateStore.keySet();
    }


    public Collection<IDataStreamInfo> values()
    {
        return delegateStore.values();
    }


    public Set<Entry<DataStreamKey, IDataStreamInfo>> entrySet()
    {
        return delegateStore.entrySet();
    }


    public boolean equals(Object o)
    {
        return delegateStore.equals(o);
    }


    public int hashCode()
    {
        return delegateStore.hashCode();
    }


    public IDataStreamInfo getOrDefault(Object key, IDataStreamInfo defaultValue)
    {
        return delegateStore.getOrDefault(key, defaultValue);
    }


    public void forEach(BiConsumer<? super DataStreamKey, ? super IDataStreamInfo> action)
    {
        delegateStore.forEach(action);
    }


    public void replaceAll(BiFunction<? super DataStreamKey, ? super IDataStreamInfo, ? extends IDataStreamInfo> function)
    {
        delegateStore.replaceAll(function);
    }


    public IDataStreamInfo putIfAbsent(DataStreamKey key, IDataStreamInfo value)
    {
        return delegateStore.putIfAbsent(key, value);
    }


    public boolean remove(Object key, Object value)
    {
        return delegateStore.remove(key, value);
    }


    public boolean replace(DataStreamKey key, IDataStreamInfo oldValue, IDataStreamInfo newValue)
    {
        return delegateStore.replace(key, oldValue, newValue);
    }


    public IDataStreamInfo replace(DataStreamKey key, IDataStreamInfo value)
    {
        return delegateStore.replace(key, value);
    }


    public IDataStreamInfo computeIfAbsent(DataStreamKey key, Function<? super DataStreamKey, ? extends DataStreamInfo> mappingFunction)
    {
        return delegateStore.computeIfAbsent(key, mappingFunction);
    }


    public IDataStreamInfo computeIfPresent(DataStreamKey key, BiFunction<? super DataStreamKey, ? super IDataStreamInfo, ? extends IDataStreamInfo> remappingFunction)
    {
        return delegateStore.computeIfPresent(key, remappingFunction);
    }


    public IDataStreamInfo compute(DataStreamKey key, BiFunction<? super DataStreamKey, ? super IDataStreamInfo, ? extends IDataStreamInfo> remappingFunction)
    {
        return delegateStore.compute(key, remappingFunction);
    }


    public IDataStreamInfo merge(DataStreamKey key, IDataStreamInfo value, BiFunction<? super IDataStreamInfo, ? super IDataStreamInfo, ? extends IDataStreamInfo> remappingFunction)
    {
        return delegateStore.merge(key, value, remappingFunction);
    }


    @Override
    public void linkTo(ISystemDescStore systemStore)
    {
        throw new UnsupportedOperationException();
    }

}
